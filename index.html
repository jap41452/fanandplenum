<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Plenum / Fan – V1 System Curve UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
  <style>
    :root{
      --bg:#f5f5f7;
      --panel:#ffffff;
      --border:#d0d5dd;
      --ink:#111827;
      --muted:#6b7280;
      --accent:#0b73c8;
      --r:12px;
      --pad:14px;
      --gap:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--ink);
      font-size:14px;
    }
    header{
      padding:10px 16px;
      border-bottom:1px solid var(--border);
      background:#f9fafb;
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:.02em;
    }
    header p{
      margin:4px 0 0;
      color:var(--muted);
      font-size:13px;
    }
    main{
      padding:var(--pad);
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:flex-start; /* left-aligned */
    }
    .col{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    /* LEFT column: 200px wide */
    .col-left{
      flex:0 0 200px;
      max-width:200px;
    }
    /* MIDDLE column: 600px wide */
    .col-mid{
      flex:0 0 600px;
      max-width:600px;
      min-width:320px;
    }
    .panel{
      background:var(--panel);
      border-radius:var(--r);
      border:1px solid var(--border);
      padding:var(--pad);
      box-shadow:0 1px 2px rgba(15,23,42,0.04);
    }
    .panel h2{
      margin:0 0 8px;
      font-size:15px;
      font-weight:600;
    }
    .panel small{
      color:var(--muted);
    }
    .grid-2{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px 12px;
      margin-top:8px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .field label{
      font-size:12px;
      color:var(--muted);
    }
    .field input, .field select{
      padding:4px 6px;
      border-radius:6px;
      border:1px solid var(--border);
      font-size:13px;
    }
    .section-label{
      margin-top:8px;
      font-size:12px;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:.06em;
      color:var(--muted);
    }
    .btn-row{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button{
      border-radius:999px;
      border:1px solid transparent;
      padding:6px 12px;
      font-size:13px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:var(--accent);
      color:#fff;
    }
    button.secondary{
      background:#fff;
      color:var(--ink);
      border-color:var(--border);
    }
    button:disabled{
      opacity:.5;
      cursor:default;
    }
    table{
      width:100%;
      border-collapse:collapse;
      margin-top:6px;
      font-size:12px;
    }
    th, td{
      border:1px solid #e5e7eb;
      padding:2px 4px;
      text-align:right;
    }
    th{
      background:#f3f4f6;
      font-weight:500;
    }
    td input{
      width:100%;
      border:none;
      outline:none;
      text-align:right;
      font-size:12px;
      padding:2px 2px;
      background:transparent;
    }
    .results-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px 12px;
      margin-top:6px;
      font-size:13px;
    }
    .result-label{
      color:var(--muted);
    }
    .result-value{
      text-align:right;
      font-feature-settings:"tnum" 1;
    }
    canvas{
      max-width:100%;
    }
    /* Fan curve panel height limit and shrink */
    .fan-panel{
      max-height:300px;   /* 50% of previous 600 */
      overflow-y:auto;
    }
    #curveChart{
      height:180px !important;  /* shrink chart area */
    }
    #view3D{
      width:100%;
      height:260px;
      border-radius:10px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
    }
    @media (max-width:860px){
      .col-left{flex:1 1 200px; max-width:none;}
      .col-mid{flex:1 1 320px; max-width:none;}
    }
  </style>
</head>
<body>
<header>
  <h1>Plenum / Fan Matching – V1 System Curve UI</h1>
  <p>Fan curve + plenum / heat-sink geometry → operating point and average velocities.</p>
</header>

<main>
  <!-- LEFT COLUMN: PANELS 1–4 -->
  <section class="col col-left">
    <!-- 1. Air & Units -->
    <div class="panel">
      <h2>1. Air & Units</h2>
      <div class="grid-2">
        <div class="field">
          <label for="units">Units</label>
          <select id="units">
            <option value="si">SI (m, Pa, m³/s)</option>
            <option value="ip">IP (in, inH₂O, cfm)</option>
          </select>
        </div>
        <div class="field">
          <label for="Tair">Air Temp (°C)</label>
          <input id="Tair" type="number" value="25">
        </div>
        <div class="field">
          <label for="rho">Density ρ (kg/m³)</label>
          <input id="rho" type="number" value="1.184">
        </div>
        <div class="field">
          <label for="mu">Viscosity μ (Pa·s)</label>
          <input id="mu" type="number" value="1.85e-5" step="1e-6">
        </div>
      </div>
    </div>

    <!-- 2. Plenum & Inlet -->
    <div class="panel">
      <h2>2. Plenum & Inlet</h2>
      <small>Geometry in current length units.</small>
      <div class="section-label">Plenum</div>
      <div class="grid-2">
        <div class="field">
          <label for="plenumW">Width W</label>
          <input id="plenumW" type="number" value="0.20" step="0.01">
        </div>
        <div class="field">
          <label for="plenumH">Height H</label>
          <input id="plenumH" type="number" value="0.05" step="0.005">
        </div>
        <div class="field">
          <label for="plenumL">Length L</label>
          <input id="plenumL" type="number" value="0.30" step="0.01">
        </div>
      </div>

      <div class="section-label">Fan / Blower Inlet</div>
      <div class="grid-2">
        <div class="field">
          <label for="inletW">Inlet width w</label>
          <input id="inletW" type="number" value="0.06" step="0.005">
        </div>
        <div class="field">
          <label for="inletH">Inlet height h</label>
          <input id="inletH" type="number" value="0.06" step="0.005">
        </div>
        <div class="field">
          <label for="inletX">Inlet x from start</label>
          <input id="inletX" type="number" value="0.10" step="0.01">
        </div>
        <div class="field">
          <label for="inletY">Inlet vertical offset</label>
          <input id="inletY" type="number" value="0.0" step="0.005">
        </div>
      </div>
    </div>

    <!-- 3. Heat Sink -->
    <div class="panel">
      <h2>3. Heat Sink (Finned)</h2>
      <small>Used for channel geometry and pressure drop.</small>
      <div class="grid-2">
        <div class="field">
          <label for="b">Fin height b</label>
          <input id="b" type="number" value="0.04" step="0.002">
        </div>
        <div class="field">
          <label for="tfin">Fin thickness t</label>
          <input id="tfin" type="number" value="0.001" step="0.0005">
        </div>
        <div class="field">
          <label for="sfin">Fin spacing s</label>
          <input id="sfin" type="number" value="0.003" step="0.0005">
        </div>
        <div class="field">
          <label for="Lfin">Fin length L<sub>f</sub></label>
          <input id="Lfin" type="number" value="0.25" step="0.01">
        </div>
        <div class="field">
          <label for="xHS">HS lead edge x</label>
          <input id="xHS" type="number" value="0.03" step="0.01">
        </div>
        <div class="field">
          <label for="WHS">HS width (if &lt; W)</label>
          <input id="WHS" type="number" value="0.20" step="0.01">
        </div>
      </div>
    </div>

    <!-- 4. Fan Curve Table -->
    <div class="panel">
      <h2>4. Fan Curve</h2>
      <small>Fan curve points (Q, Δp). Units follow selection.</small>
      <table id="fanTable">
        <thead>
        <tr>
          <th>#</th>
          <th>Q</th>
          <th>Δp</th>
        </tr>
        </thead>
        <tbody>
        <!-- Starter rows -->
        <tr><td>1</td><td><input value="0"></td><td><input value="400"></td></tr>
        <tr><td>2</td><td><input value="0.02"></td><td><input value="350"></td></tr>
        <tr><td>3</td><td><input value="0.04"></td><td><input value="280"></td></tr>
        <tr><td>4</td><td><input value="0.06"></td><td><input value="190"></td></tr>
        <tr><td>5</td><td><input value="0.08"></td><td><input value="90"></td></tr>
        <tr><td>6</td><td><input value="0.10"></td><td><input value="0"></td></tr>
        </tbody>
      </table>
      <div class="btn-row">
        <button type="button" class="secondary" id="addRowBtn">+ Row</button>
        <button type="button" class="secondary" id="delRowBtn">– Row</button>
      </div>
    </div>
  </section>

  <!-- MIDDLE COLUMN: PANELS 5, 6 (3D), 7 -->
  <section class="col col-mid">
    <!-- 5. Solve -->
    <div class="panel">
      <h2>5. Solve</h2>
      <small>Version 1: system curve & operating point.</small>
      <div class="btn-row" style="justify-content:flex-start;">
        <button type="button" id="solveBtn">Solve</button>
      </div>

      <div class="section-label">Key Results</div>
      <div class="results-grid" id="resultsGrid">
        <div class="result-label">Flow rate Q*</div>
        <div class="result-value" id="Qstar">—</div>
        <div class="result-label">Back pressure Δp*</div>
        <div class="result-value" id="Dpstar">—</div>
        <div class="result-label">Inlet velocity V<sub>in</sub></div>
        <div class="result-value" id="Vin">—</div>
        <div class="result-label">Channel velocity V<sub>ch,avg</sub></div>
        <div class="result-value" id="Vch">—</div>
      </div>
    </div>

    <!-- 6. 3D Geometry View -->
    <div class="panel">
      <h2>6. 3D Geometry View</h2>
      <small>Rotatable view of plenum, inlet, and finned heat sink.</small>
      <div id="view3D"></div>
    </div>

    <!-- 7. Fan & System Curves -->
    <div class="panel fan-panel">
      <h2>7. Fan & System Curves</h2>
      <small>Fan curve from table; system curve from pressure-drop model.</small>
      <canvas id="curveChart"></canvas>
    </div>
  </section>
</main>

<script>
  // --- Fan table row add/delete ---
  document.getElementById('addRowBtn').addEventListener('click', () => {
    const tbody = document.querySelector('#fanTable tbody');
    const idx = tbody.rows.length + 1;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${idx}</td><td><input value=""></td><td><input value=""></td>`;
    tbody.appendChild(tr);
    refreshFanChart();
  });

  document.getElementById('delRowBtn').addEventListener('click', () => {
    const tbody = document.querySelector('#fanTable tbody');
    if (tbody.rows.length > 1) tbody.deleteRow(-1);
    refreshFanChart();
  });

  // ---- Utility: read fan points from table ----
  function readFanTable() {
    const tbody = document.querySelector('#fanTable tbody');
    const pts = [];
    for (const row of tbody.rows) {
      const Q = parseFloat(row.cells[1].querySelector('input').value);
      const dp = parseFloat(row.cells[2].querySelector('input').value);
      if (!isNaN(Q) && !isNaN(dp)) pts.push({x:Q, y:dp});
    }
    pts.sort((a,b)=>a.x-b.x);
    return pts;
  }

  // ---- Fan curve interpolation (linear, with end extrapolation) ----
  function fanDeltaP(Q) {
    const pts = readFanTable();
    if (pts.length === 0) return 0;
    if (pts.length === 1) return pts[0].y;

    // Below min Q -> extrapolate using first segment
    if (Q <= pts[0].x) {
      const p0 = pts[0], p1 = pts[1];
      const t = (Q - p0.x) / (p1.x - p0.x);
      return p0.y + t*(p1.y - p0.y);
    }
    // Above max Q -> extrapolate using last segment
    const last = pts[pts.length-1];
    const secondLast = pts[pts.length-2];
    if (Q >= last.x) {
      const p0 = secondLast, p1 = last;
      const t = (Q - p0.x) / (p1.x - p0.x);
      return p0.y + t*(p1.y - p0.y);
    }

    // Inside range: find segment
    for (let i=0;i<pts.length-1;i++){
      const p0 = pts[i], p1 = pts[i+1];
      if (Q >= p0.x && Q <= p1.x) {
        const t = (Q - p0.x) / (p1.x - p0.x || 1e-9);
        return p0.y + t*(p1.y - p0.y);
      }
    }
    return last.y; // fallback
  }

  // ---- Friction factor (smooth duct) ----
  function frictionFactor(Re) {
    if (!isFinite(Re) || Re <= 0) return 0;
    if (Re < 2300) {
      return 64 / Re; // laminar
    } else {
      return 0.3164 / Math.pow(Re, 0.25); // Blasius turbulent
    }
  }

  // ---- System pressure drop Δp_sys(Q) ----
  function systemDeltaP(Q) {
    if (Q <= 0) return 0;

    // Air properties
    const rho = parseFloat(document.getElementById('rho').value) || 1.184;
    const mu  = parseFloat(document.getElementById('mu').value)  || 1.85e-5;

    // Geometry
    const W  = parseFloat(document.getElementById('plenumW').value) || 0.20;
    const H  = parseFloat(document.getElementById('plenumH').value) || 0.05;
    const L  = parseFloat(document.getElementById('plenumL').value) || 0.30;
    const wIn = parseFloat(document.getElementById('inletW').value) || 0.06;
    const hIn = parseFloat(document.getElementById('inletH').value) || 0.06;

    const b   = parseFloat(document.getElementById('b').value)    || 0.04;
    const s   = parseFloat(document.getElementById('sfin').value) || 0.003;
    const t   = parseFloat(document.getElementById('tfin').value) || 0.001;
    const Lf  = parseFloat(document.getElementById('Lfin').value) || 0.25;
    const WHS = parseFloat(document.getElementById('WHS').value)  || W;

    // --- Inlet loss ---
    const Ain = Math.max(wIn * hIn, 1e-9);
    const Vin = Q / Ain;
    const Kin = 1.0;
    const dp_in = Kin * 0.5 * rho * Vin * Vin;

    // --- Plenum above fins (assume H_p = H - b) ---
    const Hp = Math.max(H - b, 1e-6);
    const Apl = Math.max(W * Hp, 1e-9);
    const Vpl = Q / Apl;
    const Dh_pl = 2 * W * Hp / Math.max(W + Hp, 1e-9);
    const Re_pl = rho * Vpl * Dh_pl / mu;
    const f_pl  = frictionFactor(Re_pl);
    const dp_pl = f_pl * (L / Math.max(Dh_pl, 1e-9)) * 0.5 * rho * Vpl * Vpl;

    // --- Heat-sink channels ---
    let dp_ch = 0;
    const pitch = s + t;
    if (pitch > 0 && WHS > 0 && b > 0) {
      let Nch = Math.floor((WHS + s) / pitch);
      if (Nch < 1) Nch = 1;
      const g = s;         // clear gap
      const Hc = b;
      const AchTot = Nch * g * Hc;
      if (AchTot > 0) {
        const Vch = Q / AchTot;
        const Dh_ch = 2 * g * Hc / Math.max(g + Hc, 1e-9);
        const Re_ch = rho * Vch * Dh_ch / mu;
        const f_ch  = frictionFactor(Re_ch);

        const dp_major = f_ch * (Lf / Math.max(Dh_ch, 1e-9)) * 0.5 * rho * Vch * Vch;
        const Kminor = 2.0; // entry + exit lumped
        const dp_minor = Kminor * 0.5 * rho * Vch * Vch;

        dp_ch = dp_major + dp_minor;
      }
    }

    const dp_sys = dp_in + dp_pl + dp_ch;
    return dp_sys;
  }

  // --- Chart.js: fan + system curves ---
  const ctx = document.getElementById('curveChart').getContext('2d');
  const chartConfig = {
    type: 'line',
    data: {
      datasets: [
        {
          label: 'Fan curve',
          data: [],
          borderWidth: 2,
          tension: 0.2,
          pointRadius: 2
        },
        {
          label: 'System curve',
          data: [],
          borderWidth: 2,
          borderDash: [4,4],
          tension: 0.2,
          pointRadius: 0
        },
        {
          label: 'Operating point',
          data: [],
          type: 'scatter',
          pointRadius: 4,
          pointStyle: 'circle'
        }
      ]
    },
    options: {
      responsive:true,
      maintainAspectRatio:false,
      scales: {
        x: {
          type: 'linear',
          title:{display:true,text:'Flow Q'},
          ticks:{maxTicksLimit:6}
        },
        y: {
          title:{display:true,text:'Δp'},
          ticks:{maxTicksLimit:6}
        }
      },
      plugins:{
        legend:{display:true,position:'bottom'}
      }
    }
  };
  const curveChart = new Chart(ctx, chartConfig);

  function refreshFanChart() {
    const pts = readFanTable();
    chartConfig.data.datasets[0].data = pts;
    curveChart.update();
  }
  refreshFanChart();

  // ---- Operating point solver (scan) ----
  function computeOperatingPoint() {
    const fanPts = readFanTable();
    if (fanPts.length < 2) {
      alert("Need at least two fan curve points.");
      return null;
    }
    const Qmax = fanPts[fanPts.length-1].x;
    if (!isFinite(Qmax) || Qmax <= 0) {
      alert("Fan curve Q values must be positive.");
      return null;
    }

    const nScan = 80;
    let bestQ = 0;
    let bestErr = Infinity;
    const sysCurve = [];

    for (let i=0; i<=nScan; i++) {
      const Q = Qmax * i / nScan;
      const dpFan = fanDeltaP(Q);
      const dpSys = systemDeltaP(Q);
      const err = Math.abs(dpFan - dpSys);
      if (err < bestErr) {
        bestErr = err;
        bestQ = Q;
      }
      sysCurve.push({x:Q, y:dpSys});
    }

    const dpStarFan = fanDeltaP(bestQ);
    return {
      Qstar: bestQ,
      Dpstar: dpStarFan,
      sysCurve
    };
  }

  // ---- Solve button wiring ----
  document.getElementById('solveBtn').addEventListener('click', () => {
    const res = computeOperatingPoint();
    if (!res) return;

    const {Qstar, Dpstar, sysCurve} = res;

    // Update results panel
    const wIn = parseFloat(document.getElementById('inletW').value) || 0;
    const hIn = parseFloat(document.getElementById('inletH').value) || 0;
    const Ain = Math.max(wIn * hIn, 1e-9);
    const Vin = Qstar / Ain;

    const W   = parseFloat(document.getElementById('WHS').value)  || 0;
    const s   = parseFloat(document.getElementById('sfin').value) || 0;
    const t   = parseFloat(document.getElementById('tfin').value) || 0;
    const b   = parseFloat(document.getElementById('b').value)    || 0;
    let Vch = NaN;
    const pitch = s + t;
    if (pitch > 0 && W > 0 && b > 0) {
      let Nch = Math.floor((W + s) / pitch);
      if (Nch < 1) Nch = 1;
      const AchTot = Nch * s * b;
      if (AchTot > 0) {
        Vch = Qstar / AchTot;
      }
    }

    document.getElementById('Qstar').textContent = Qstar.toExponential(3);
    document.getElementById('Dpstar').textContent = Dpstar.toFixed(1);
    document.getElementById('Vin').textContent   = Vin.toFixed(2);
    document.getElementById('Vch').textContent   = isFinite(Vch) ? Vch.toFixed(2) : '—';

    // Update chart: fan curve already in dataset[0]
    chartConfig.data.datasets[1].data = sysCurve;
    chartConfig.data.datasets[2].data = [{x:Qstar,y:Dpstar}];
    curveChart.update();
  });

  // =========================
  // 3D VIEW (Three.js)
  // =========================
  let scene, camera, renderer, controls, plenumGroup;
  let threeInitialized = false;

  function init3D() {
    if (threeInitialized) return;
    threeInitialized = true;

    const container = document.getElementById('view3D');
    const w = container.clientWidth || 580;
    const h = container.clientHeight || 260;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf9fafb);

    camera = new THREE.PerspectiveCamera(40, w/h, 0.1, 1000);
    camera.position.set(15, 10, 12);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(w, h);
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 0, 0);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.5);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // Group to hold plenum + fins
    plenumGroup = new THREE.Group();
    scene.add(plenumGroup);

    // Simple ground grid for reference
    const grid = new THREE.GridHelper(20, 20, 0xbbbbbb, 0xe5e5e5);
    grid.position.y = -5;
    scene.add(grid);

    // Initial geometry
    update3DGeometry();

    // Resize handling
    window.addEventListener('resize', onWindowResize3D);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  }

  function onWindowResize3D() {
    if (!renderer || !camera) return;
    const container = document.getElementById('view3D');
    const w = container.clientWidth || 580;
    const h = container.clientHeight || 260;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }

  function clearGroup(group) {
    while (group.children.length > 0) {
      const obj = group.children[0];
      group.remove(obj);
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (Array.isArray(obj.material)) {
          obj.material.forEach(m => m.dispose());
        } else {
          obj.material.dispose();
        }
      }
    }
  }

  function update3DGeometry() {
    if (!plenumGroup) return;

    clearGroup(plenumGroup);

    // Get geometry inputs
    const W  = parseFloat(document.getElementById('plenumW').value) || 0.20;
    const H  = parseFloat(document.getElementById('plenumH').value) || 0.05;
    const L  = parseFloat(document.getElementById('plenumL').value) || 0.30;
    const wIn = parseFloat(document.getElementById('inletW').value) || 0.06;
    const hIn = parseFloat(document.getElementById('inletH').value) || 0.06;

    const b   = parseFloat(document.getElementById('b').value)    || 0.04;
    const s   = parseFloat(document.getElementById('sfin').value) || 0.003;
    const t   = parseFloat(document.getElementById('tfin').value) || 0.001;
    const Lf  = parseFloat(document.getElementById('Lfin').value) || 0.25;
    const xHS = parseFloat(document.getElementById('xHS').value)  || 0.03;
    const WHS = parseFloat(document.getElementById('WHS').value)  || W;

    const maxDim = Math.max(L, W, H, 0.1);
    const scale = 10 / maxDim; // scale so geometry fits nicely
    const Ls = L * scale;
    const Ws = W * scale;
    const Hs = H * scale;

    // Plenum box (wireframe + translucent)
    const plenumGeom = new THREE.BoxGeometry(Ls, Hs, Ws);
    const plenumWire = new THREE.EdgesGeometry(plenumGeom);
    const wireMat = new THREE.LineBasicMaterial({color:0x111111});
    const wireMesh = new THREE.LineSegments(plenumWire, wireMat);
    plenumGroup.add(wireMesh);

    const plenumMat = new THREE.MeshBasicMaterial({
      color:0xcbd5f5,
      transparent:true,
      opacity:0.08,
      depthWrite:false
    });
    const plenumMesh = new THREE.Mesh(plenumGeom, plenumMat);
    plenumGroup.add(plenumMesh);

    // Inlet on one side (front x ~ -Ls/2)
    const AinW = Math.min(wIn, L) * scale;
    const AinH = Math.min(hIn, H) * scale;
    const inletGeom = new THREE.BoxGeometry(0.02*Ls, AinH, AinW);
    const inletMat = new THREE.MeshBasicMaterial({color:0x4b5563});
    const inletMesh = new THREE.Mesh(inletGeom, inletMat);

    inletMesh.position.set(-Ls/2 - 0.01*Ls, 0, 0); // centered in H & W
    plenumGroup.add(inletMesh);

    // Heat sink base & fins
    if (b > 0 && Lf > 0 && WHS > 0) {
      const baseThickness = 0.003 * scale * maxDim; // small base
      const baseGeom = new THREE.BoxGeometry(
        Math.min(Lf, L - xHS) * scale,
        baseThickness,
        Math.min(WHS, W) * scale
      );
      const baseMat = new THREE.MeshPhongMaterial({color:0x9ca3af});
      const baseMesh = new THREE.Mesh(baseGeom, baseMat);

      const xHSs = (-Ls/2) + xHS * scale + baseGeom.parameters.width/2;
      const yBase = -Hs/2 + baseThickness/2;
      baseMesh.position.set(xHSs, yBase, 0);
      plenumGroup.add(baseMesh);

      // Fins
      const pitch = s + t;
      if (pitch > 0) {
        let Nch = Math.floor((WHS + s) / pitch);
        if (Nch < 1) Nch = 1;
        const maxFinsToDraw = 60; // limit for performance
        const drawEvery = Math.max(1, Math.floor(Nch / maxFinsToDraw));

        const finHeight = Math.min(b, H) * scale;
        const finThick = t * scale;
        const finLen = baseGeom.parameters.width; // along x
        const WfinTotal = Math.min(WHS, W) * scale;

        for (let i=0; i<Nch; i+=drawEvery) {
          const z0 = -WfinTotal/2 + (i + 0.5) * pitch * scale;
          if (z0 < -WfinTotal/2 || z0 > WfinTotal/2) continue;

          const finGeom = new THREE.BoxGeometry(finLen, finHeight, finThick);
          const finMat = new THREE.MeshPhongMaterial({color:0x2563eb});
          const finMesh = new THREE.Mesh(finGeom, finMat);

          const yFin = yBase + baseThickness/2 + finHeight/2;
          finMesh.position.set(xHSs, yFin, z0);
          plenumGroup.add(finMesh);
        }
      }
    }

    // Recenter group (already centered, but just in case)
    plenumGroup.position.set(0,0,0);
  }

  // Initialize 3D once DOM is ready
  window.addEventListener('load', () => {
    init3D();
  });

  // Update 3D when geometry changes
  const geomIds = [
    'plenumW','plenumH','plenumL',
    'inletW','inletH',
    'xHS','Lfin','b','WHS','sfin','tfin'
  ];
  geomIds.forEach(id=>{
    document.getElementById(id).addEventListener('input', () => {
      update3DGeometry();
    });
  });
</script>
</body>
</html>



